<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Compact Syntax for RELAX NG</title>
</head>
<body>
<h1>Compact Syntax for RELAX NG</h1>

<p>This document describes the Compact Syntax for <a
href="http://relaxng.org">RELAX NG</a> (a schema language for XML).
The design goals of this syntax are:</p>

<ul>

<li>Non-XML syntax.</li>

<li>Maximize readability.</li>

<li>Support all features of RELAX NG.</li>

<li>Support separate translation.  A RELAX NG schema may be spread
amongst multiple files.  It must be possible to represent each of the
files separately in the compact syntax. The representation of each
file must not depend on the other files.</li>

</ul>

<p>The syntax is similar to the type syntax in the <a href=
"http://www.w3.org/TR/2001/WD-query-semantics-20010607/#sec_grammar_abstract_types"
>XQuery 1.0 Formal Semantics</a> W3C Working Draft.</p>

<h2>BNF</h2>

<p>The syntax is defined by the following BNF:</p>

<pre>
topLevel ::= decl* topLevelBody

topLevelBody ::= pattern | grammar

decl ::=
  "namespace" identifier "=" (literal | "inherit")
  | "default" "namespace" identifier? "=" (literal | "inherit")
  | "datatypes" identifier "=" literal

pattern ::=
  particle
  | particle ("|" particle)+
  | particle ("," particle)+
  | particle ("&amp;" particle)+
  | exceptParticle

particle ::= annotations primary followAnnotations occurrence?

exceptParticle ::=
  annotations datatypeName params? "-" annotations primary followAnnotations

primary ::=
  "(" pattern ")"
  | "element" nameClass "{" pattern "}"
  | "attribute" nameClass "{" pattern "}"
  | "mixed" "{" pattern "}"
  | "empty"
  | "notAllowed"
  | "text"
  | "list" "{" pattern "}"
  | datatypeName params?
  | datatypeName? datatypeValue
  | "grammar" "{" grammar "}"
  | ref
  | "parent" ref
  | "externalRef" literal inherit?

occurrence = ("*" | "+" | "?") followAnnotations

nameClass ::=
  basicNameClass followAnnotations
  | basicNameClass followAnnotations ("|" basicNameClass followAnnotations)+
  | openNameClass "-" basicNameClass followAnnotations

basicNameClass ::=
  annotations (identifier | CName)
  | openNameClass
  | annotations "(" nameClass ")"

openNameClass ::= annotations (nsName | anyName)

ref ::= identifierNotKeyword

datatypeName ::= CName | "string" | "token"

datatypeValue ::= literal

params ::= "{" (annotations identifier "=" literal)+ "}"

grammar ::= (definition | include | div | annotationElementNotKeyword)*

definition ::= annotations subject ("=" | "|=" | "&amp;=") pattern

subject ::= "start" | identifierNotKeyword

include ::= annotations "include" literal inherit? includeBody?

includeBody ::= "{" (definition | includeDiv | annotationElementNotKeyword)* "}"

div ::= annotations "div" "{" grammar "}"

includeDiv ::= annotations "div" includeBody

inherit ::= "inherit" "=" identifier

followAnnotations ::= ("&gt;&gt;" annotationElement)*

annotations ::= documentation* otherAnnotation?

otherAnnotation ::= "[" prefixedAnnotationAttribute* annotationElement* "]"

annotationAttribute ::= (identifier | CName) "=" literal

prefixedAnnotationAttribute ::= CName "=" literal

annotationElement ::= (identifier | CName) annotationElementBody

annotationElementNotKeyword ::=
  (identifierNotKeyword | CName) annotationElementBody

annotationElementBody ::=
  "[" annotationAttribute* (annotationElement | literal)* "]"

identifierNotKeyword ::= identifier - keyword

identifier ::= NCName | escapedIdentifier

keyword ::=
  "attribute" | "default" | "datatypes" | "div" | "element"
  | "empty" | "externalRef" | "grammar" | "include" | "inherit"
  | "list" | "mixed" | "namespace" | "notAllowed" | "parent"
  | "start" | "string" | "text" | "token"

CName ::= NCName ":" NCName
escapedIdentifier ::= "\" NCName
literal ::= literalSegment+
literalSegment ::= '"' [^"]* '"' | "'" [^']* "'"
nsName ::= NCName ":*"
anyName ::= "*"
documentation ::= "##" [^#xA]* (#xA [#x9#x20]* "##" [^#xA])*
</pre>

<p>The contents of consecutive <code>literalSegment</code>s in a
<code>literal</code> are concatenated.</p>

<p>Comments start with a <code>#</code> followed by anything other than <code>#</code>
and continue to the end of the line.</p>

<p><code>element</code> is defined in the <a
href="http://www.w3.org/TR/REC-xml#NT-element">XML 1.0 Recommendation</a>;
<code>NCName</code> is defined in the
<a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">XML Namespaces
Recommendation</a>.</p>

<p>Note that keywords are case-sensitive. To use a keyword as the name
of a definition, the keyword must be escaped with <code>\</code>.  It
is not necessary to escape a keyword that is used as the name of an
element, attribute or datatype parameter.</p>

<h2>Character escapes</h2>

<p>Before parsing against the above grammar, the input string is first
preprocessed by interpreting escapes. A sequence of characters
<code>\x{<var>N</var>}</code>, where <code><var>N</var></code>
consists of one or more hexadecimal digits, is replaced by the Unicode
character with code <code><var>N</var></code>. For example,</p>

<pre>
element \x{66}\x{6f}\x{6f} { empty }
</pre>

<p>is equivalent to</p>

<pre>
element foo { empty }
</pre>

<h2>Mapping to RELAX NG Syntax</h2>

<p>The correspondence between the compact syntax and RELAX NG's XML
syntax is shown by the following tables.</p>

<h3>Patterns</h3>

<table border="1">
<tr>
<th>Compact Syntax</th>
<th>RELAX NG Syntax</th>
</tr>
<tr>
<td>
<code><var>p1</var> | <var>p2</var></code>
</td>
<td><code>&lt;choice> <var>p1</var> <var>p2</var> &lt;/choice></code></td>
</tr>
<tr>
<td>
<code><var>p1</var> , <var>p2</var></code>
</td>
<td><code>&lt;group> <var>p1</var> <var>p2</var> &lt;/group></code></td>
</tr>
<tr>
<td>
<code><var>p1</var> &amp; <var>p2</var></code>
</td>
<td><code>&lt;interleave> <var>p1</var> <var>p2</var> &lt;/interleave></code></td>
</tr>
<tr>
<td>
<code><var>p</var>*</code>
</td>
<td><code>&lt;zeroOrMore> <var>p</var> &lt;/zeroOrMore></code></td>
</tr>
<tr>
<td>
<code><var>p</var>+</code>
</td>
<td><code>&lt;oneOrMore> <var>p</var> &lt;/oneOrMore></code></td>
</tr>
<tr>
<td>
<code><var>p</var>?</code>
</td>
<td><code>&lt;optional> <var>p</var> &lt;/optional></code></td>
</tr>
<tr>
<td>
<code>(<var>p</var>)</code>
</td>
<td><code><var>p</var></code></td>
</tr>
<tr>
<td>
<code>element <var>QName</var> { <var>p</var> }</code>
</td>
<td>
<code>&lt;element name="<var>QName</var>"> <var>p</var> &lt;/element></code>
</td>
</tr>
<tr>
<td>
<code>element <var>nameClass</var> { <var>p</var> }</code>
</td>
<td>
<code>&lt;element> <var>nameClass</var> <var>p</var> &lt;/element></code>
</td>
</tr>
<tr>
<td>
<code>attribute <var>QName</var> { <var>p</var> }</code>
</td>
<td>
<code>&lt;attribute name="<var>QName</var>"> <var>p</var> &lt;/attribute></code>
</td>
</tr>
<tr>
<td>
<code>attribute <var>nameClass</var> { <var>p</var> }</code>
</td>
<td>
<code>&lt;attribute> <var>nameClass</var> <var>p</var> &lt;/attribute></code>
</td>
</tr>
<tr>
<td><code>empty</code></td>
<td><code>&lt;empty/></code></td>
</tr>
<tr>
<td><code>notAllowed</code></td>
<td><code>&lt;notAllowed/></code></td>
</tr>
<tr>
<td><code>text</code></td>
<td><code>&lt;text/></code></td>
</tr>
<tr>
<td>
<code>mixed { <var>p</var> }</code>
</td>
<td>
<code>&lt;mixed> <var>p</var> &lt;/mixed></code>
</td>
</tr>
<tr>
<td>
<code>list { <var>p</var> }</code>
</td>
<td>
<code>&lt;list> <var>p</var> &lt;/list></code>
</td>
</tr>
<tr>
<td><code><var>identifierNotKeyword</var></code></td>
<td><code>&lt;ref name="<var>identifierNotKeyword</var>"/&gt;</code></td>
</tr>
<tr>
<td><code>\<var>identifier</var></code></td>
<td><code>&lt;ref name="<var>identifier</var>"/&gt;</code></td>
</tr>
<tr>
<td><code>externalRef "<var>uri</var>"</code></td>
<td><code>&lt;externalRef href="<var>uri</var>"/></code></td>
</tr>
<tr>
<td><code>parent <var>identifier</var></code></td>
<td><code>&lt;parentRef name="<var>identifier</var>"/&gt;</code></td>
</tr>
<tr>
<td><code>grammar { <var>defs</var> }</code></td>
<td><code>&lt;grammar> <var>defs</var> &lt;/grammar></code></td>
</tr>
<tr>
<td><code>"<var>string</var>"</code></td>
<td><code>&lt;value><var>string</var>&lt;/value></code></td>
</tr>
<tr>
<td><code>string</code></td>
<td><code>&lt;data type="string"/></code></td>
</tr>
<tr>
<td><code>token</code></td>
<td><code>&lt;data type="token"/></code></td>
</tr>
<tr>
<td><code><var>prefix</var>:<var>localName</var></code></td>
<td><code>&lt;data type="<var>localName</var>" datatypeLibrary="<var>uri</var>"/></code></td>
</tr>
<tr>
<td><code><var>prefix</var>:<var>localName</var> "<var>string</var>"</code></td>
<td><code>&lt;value type="<var>localName</var>" datatypeLibrary="<var>uri</var>"><var>string</var>&lt;/value></code></td>
</tr>
<tr>
<td><code><var>prefix</var>:<var>localName</var> - <var>p</var></code></td>
<td><code>&lt;data type="<var>localName</var>" datatypeLibrary="<var>uri</var>">&lt;except> <var>p</var> &lt;/except>&lt;/data></code></td>
</tr>
<tr>
<td><code><var>prefix</var>:<var>localName</var> { <var>params</var> }</code></td>
<td><code>&lt;data type="<var>localName</var>"
datatypeLibrary="<var>uri</var>">
<var>params</var>
&lt;/data></code></td>
</tr>
</table>

<h3>Name classes</h3>

<table border="1">
<tr>
<th>Compact Syntax</th>
<th>RELAX NG Syntax</th>
</tr>
<tr>
<td><code><var>QName</var></code></td>
<td><code>&lt;name><var>QName</var>&lt;/name></code></td>
</tr>
<tr>
<td><code><var>prefix</var>:*</code></td>
<td><code>&lt;nsName ns="<var>uri</var>"/></code></td>
</tr>
<tr>
<td><code><var>prefix</var>:* - <var>nameClass</var></code></td>
<td><code>&lt;nsName ns="<var>uri</var>"&lt;except> <var>nameClass</var> &lt;/except>&lt;/nsName></code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>&lt;anyName/></code></td>
</tr>
<tr>
<td><code>* - <var>nameClass</var></code></td>
<td><code>&lt;anyName>&lt;except> <var>nameClass</var> &lt;/except>&lt;/anyName></code></td>
</tr>
<tr>
<td>
<code><var>nameClass1</var> | <var>nameClass2</var></code>
</td>
<td><code>&lt;choice> <var>nameClass1</var> <var>nameClass2</var> &lt;/choice></code></td>
</tr>
<tr>
<td>
<code>(<var>nameClass</var>)</code>
</td>
<td><code><var>nameClass</var></code></td>
</tr>
</table>

<h3>Parameters</h3>

<table border="1">
<tr>
<th>Compact Syntax</th>
<th>RELAX NG Syntax</th>
</tr>
<tr>
<td><code><var>localName</var> = "<var>string</var>"</code></td>
<td><code>&lt;param name="<var>localName</var>"><var>string</var>&lt;/param></code></td>
</tr>
</table>

<h3>Grammars</h3>

<table border="1">
<tr>
<th>Compact Syntax</th>
<th>RELAX NG Syntax</th>
</tr>
<tr>
<td><code><var>identifierNotKeyword</var> = <var>p</var></code></td>
<td><code>&lt;define name="<var>identifierNotKeyword</var>"> <var>p</var> &lt;/define></code></td>
</tr>
<tr>
<td><code><var>identifierNotKeyword</var> |= <var>p</var></code></td>
<td><code>&lt;define name="<var>identifierNotKeyword</var>" combine="choice"> <var>p</var> &lt;/define></code></td>
</tr>
<tr>
<td><code><var>identifierNotKeyword</var> &amp;= <var>p</var></code></td>
<td><code>&lt;define name="<var>identifierNotKeyword</var>" combine="interleave"> <var>p</var> &lt;/define></code></td>
</tr>
<tr>
<td><code>start = <var>p</var></code></td>
<td><code>&lt;start> <var>p</var> &lt;/start></code></td>
</tr>
<tr>
<td><code>\<var>identifier</var> = <var>p</var></code></td>
<td><code>&lt;define name="<var>identifier</var>"> <var>p</var> &lt;/define></code></td>
</tr>
<tr>
<td><code>include "<var>uri</var>"</code></td>
<td><code>&lt;include href="<var>uri</var>"/></code></td>
</tr>
<tr>
<td><code>include "<var>uri</var>"</code> { <var>defs</var> }</td>
<td><code>&lt;include href="<var>uri</var>"> <var>defs</var> &lt;/include></code></td>
</tr>
</table>

<h2>Declarations</h2>

<p>A <code>datatypes</code> declaration declares a prefix used in a
QName identifying a datatype. For example,</p>

<pre>
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"
element height { xsd:double }
</pre>

<p>In fact, in the above example, the <code>datatypes</code>
declaration is not required: if there is no declaration for the prefix
<code>xsd</code>, then the above declaration will be assumed.</p>

<p>A <code>namespace</code> declaration declares a prefix used in a
QName specifying the name of an element or attribute.  For
example,</p>

<pre>
namespace rng = "http://relaxng.org/ns/structure/1.0"
element rng:text { empty }
</pre>


<p>A <code>default namespace</code> declaration declares
the namespace used for unprefixed names specifying the name
of an element (but not of an attribute). For example,</p>

<pre>
default namespace = "http://example.com"
element foo { attribute bar { string } }
</pre>

<p>is equivalent to</p>

<pre>
namespace ex = "http://example.com"
element ex:foo { attribute bar { string } }
</pre>

<p>A <code>default namespace</code> declaration may have a prefix
as well.  For example,</p>

<pre>
default namespace ex = "http://example.com"
</pre>

<p>is equivalent to</p>

<pre>
default namespace = "http://example.com"
namespace ex = "http://example.com"
</pre>

<p>The URI may be empty.  This makes the prefix stand for the absent
namespace URI.  This is necessary for specifying a name class that
matches any name with an absent namespace URI. For example:</p>

<pre>
namespace local = ""
element foo { attribute * - local:* { string }* }
</pre>

<p>is equivalent to</p>

<pre>
&lt;element xmlns="http://relaxng.org/ns/structure/1.0""
         name="foo"
         ns="http://example.com">
  &lt;zeroOrMore>
    &lt;attribute>
      &lt;anyName>
	&lt;except>
	  &lt;nsName ns=""/>
	&lt;/except>
      &lt;/anyName>
      &lt;data type="string"/>
    &lt;/attribute>
  &lt;zeroOrMore>
&lt;/element>
</pre>

<p>RELAX NG has the feature that if a file does not specify an
<code>ns</code> attribute then the <code>ns</code>
attribute can be inherited from the including file.  To support this
feature, the keyword <code>inherit</code> can be specified in place of
the namespace URI in a namespace declaration. For example,</p>

<pre>
default namespace this = inherit
element foo { element * - this:* { string }* }
</pre>

<p>is equivalent to</p>

<pre>
&lt;element xmlns="http://relaxng.org/ns/structure/1.0""
         name="foo">
  &lt;zeroOrMore>
    &lt;element>
      &lt;anyName>
	&lt;except>
	  &lt;nsName/>
	&lt;/except>
      &lt;/anyName>
      &lt;data type="string"/>
    &lt;/element>
  &lt;zeroOrMore>
&lt;/element>
</pre>

<p>In addition, the <code>include</code> and <code>externalRef</code>
patterns can specify <code>inherit = <var>prefix</var></code> to
specify the namespace to be inherited by the referenced file. For
example,</p>

<pre>
namespace x = "http://www.example.com"
externalRef "foo.rng" inherit = x
</pre>

<p>is equivalent to</p>

<pre>
&lt;externalRef href="foo.rng"
  ns="http://www.example.com"
  xmlns="http://relaxng.org/ns/structure/1.0"/>
</pre>

<p>In the absence of an <code>inherit</code> parameter on
<code>include</code> or <code>externalRef</code>, the default
namespace will be inherited by the referenced file.</p>

<p>In the absence of a <code>default namespace</code> declaration, a
declaration of</p>

<pre>
default namespace = inherit
</pre>

<p>is assumed.</p>

<h2>Annotations</h2>

<p>RELAX NG supports two kinds of annotation: element annotations and
attribute annotations.  In the compact syntax, attribute annotations
are written in a similar way to the XML syntax.  For example,
<code>xml:lang = "en"</code>.  Element annotations are written
using the syntax</p>

<pre>
<var>elementName</var> [ <var>attributesAndContent</var> ]
</pre>

<p>where <code><var>elementName</var></code> is the QName of the
element and <code><var>attributesAndContent</var></code> is a list of
attributes followed by a list of elements and literals.</p>

<p>Annotations are attached in one of the following ways:</p>

<ul>

<li>an element annotation is allowed anywhere a definition is
allowed</li>

<li>any syntactic object (a pattern, a name class, a component of a
grammar) may be preceded by a list of annotation attributes and
annotation elements in square brackets; the annotation elements are
equivalent to initial child elements in the XML syntax; however, when
applied to RELAX NG elements that cannot have child elements, they are
equivalent to following sibling elements</li>

<li>a pattern or a name class can be followed by <code>&gt;&gt;</code> and
then an element annotation; this is equivalent to a following sibling
element in the XML syntax</li>

</ul>

<p>For example,</p>

<pre>
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

[ a:documentation [ "Represents a foo" ] ]
element foo
{
  [ a:defaultValue = "42" ]
  attribute bar { text }?,
  empty
}
</pre>

<p>turns into</p>

<pre>
&lt;element name="foo"
    xmlns="http://relaxng.org/ns/structure/1.0"
    xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
  &lt;a:documentation>Represents a foo&lt;/a:documentation>
  &lt;optional>
    &lt;attribute a:defaultValue="42" name="bar">
      &lt;text/>
    &lt;/attribute>
  &lt;/optional>
  &lt;empty/>
&lt;/element>
</pre>

<p>Here's another example using the <a
href="http://homepage2.nifty.com/okajima/relaxngcc/index_en.htm">RelaxNGCC</a>
annotations:</p>

<pre>
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"
namespace c = "http://www.xml.gr.jp/xmlns/relaxngcc"

[ c:class="sample1" ]
start =
  element team {
    element player {
      attribute number {
        [ c:alias="number" ]
	xsd:positiveInteger >> c:java [ "System.out.println(number);" ]
      },
      element name {
        [ c:alias="name" ]
	text >> c:java [ "System.out.println(name);" ]
      }
    }+
  }
</pre>

<p>turns into</p>

<pre>
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"
         datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
         xmlns:c="http://www.xml.gr.jp/xmlns/relaxngcc">
  &lt;start c:class="sample1">
    &lt;element name="team">
      &lt;oneOrMore>
        &lt;element name="player">
          &lt;attribute name="number">
            &lt;data c:alias="number" type="positiveInteger"/>
            &lt;c:java>System.out.println(number);&lt;/c:java>
          &lt;/attribute>
          &lt;element name="name">
            &lt;text c:alias="name"/>
            &lt;c:java>System.out.println(name);&lt;/c:java>
          &lt;/element>
        &lt;/element>
      &lt;/oneOrMore>
    &lt;/element>
  &lt;/start>
&lt;/grammar>
</pre>

<p>In addition, there is a special syntax for specifying
<code>documentation</code> elements from the
<code>http://relaxng.org/ns/compatibility/annotations/1.0</code>
namespace as described in <a
href="http://www.oasis-open.org/committees/relax-ng/compatibility.html#IDAC1YR"
>RELAX NG DTD Compatibility</a>.  For example,</p>

<pre>
## Represents a foo
element foo { empty }
</pre>

<p>turns into</p>

<pre>
&lt;element name="foo"
    xmlns="http://relaxng.org/ns/structure/1.0"
    xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
  &lt;a:documentation>Represents a foo&lt;/a:documentation>
  &lt;empty/>
&lt;/element>
</pre>

<h2>Open issues</h2>

<h3>Namespace declarations and <code>value</code></h3>

<p>There is a problem in translating a schema such as</p>

<pre>
&lt;element xmlns="http://relaxng.org/ns/structure/1.0""
         datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
         name="foo">
  &lt;choice>
    &lt;value type="QName" xmlns:bar="http://example.com/1">bar:baz&lt;/value>
    &lt;value type="QName" xmlns:bar="http://example.com/2">bar:baz&lt;/value>
  &lt;/choice>
&lt;/element>
</pre>

<p>into the compact syntax. Although this can be translated, for
example, into</p>

<pre>
namespace bar1 = "http://example.com/1"
namespace bar2 = "http://example.com/2"
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"

element foo { xsd:QName "bar1:baz" | xsd:QName "bar2:baz" }
</pre>

<p>doing so requires that the translator have knowledge of the QName
datatype.</p>

<address>
<a href="mailto:jjc@jclark.com">James Clark</a>
</address>

</body>
</html>
