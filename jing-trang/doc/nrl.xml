<html>

<head>
<title>Namespace Routing Language (NRL)</title>
</head>
<body>

<h1>Namespace Routing Language (NRL)</h1>

<p>The XML Namespaces Recommendation allows an XML document to be
composed of elements and attributes from multiple independent
namespaces. Each of these namespaces may have its own schema.  The
problem then arises of how the schemas can be composed in order to
allow validation of the complete document. This document proposes the
Namespace Routing Language (NRL) as a solution to this problem.  NRL
is an evolution of the author's earlier Modular Namespaces (MNS)
language.</p>

<p>A sample implementation of NRL is included in Jing.</p>

<h2>Getting started</h2>

<p>In its simplest form, an NRL schema consists of a mapping from
namespace URIs to schema URIs.  An NRL schema is written in XML. Here
is an example:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl">
<namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
  <validate schema="soap-envelope.xsd"/>
</namespace>
<namespace ns="http://www.w3.org/1999/xhtml">
  <validate schema="xhtml.rng"/>
</namespace>
</rules>
</xml>

<p>We will call a schema referenced by an NRL schema a
<i>subschema</i>.  In the above example,
<code>soap-envelope.xsd</code> is the subschema for the namespace URI
<code>http://schemas.xmlsoap.org/soap/envelope/</code> and
<code>xhtml.rng</code> is the subschema for the namespace URI
<code>http://www.w3.org/1999/xhtml</code>.</p>

<p>The absent namespace can be mapped to a namespace URI by using
<code>ns=""</code>.</p>

<h2>Specifying the schema</h2>

<p>In most cases the schema will be in some namespaced XML dialect,
and the type of schema can be automatically detected from the
namespace URI of the root element.  In cases where the schema is not
in XML and there is no MIME type information available to determine
the type, a <code>schemaType</code> attribute can be used to specify the
type.  The value of this should be a MIME media type.  For RELAX NG
compact syntax, a value of <code>application/x-rnc</code> should be
used.</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl">
<namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
  <validate schema="soap-envelope.xsd"/>
</namespace>
<namespace ns="http://www.w3.org/1999/xhtml">
  <validate schema="xhtml.rnc" schemaType="application/x-rnc"/>
</namespace>
</rules>
</xml>

<p>XXX schema options</p>

<h2>Processing model</h2>

<p>NRL validation has two inputs: a document to be validated and an
NRL schema.  We will call the document to be validated the
<i>instance</i>. NRL validation divides the instance into sections,
each of which contains elements from a single namespace, and validates
each section separately against the subschema for its namespace.</p>

<p>Thus, the following instance:</p>

<xml>
<env:Envelope xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"
              xmlns="http://www.w3.org/1999/xhtml">
<env:Body>
<xhtml>
<head>
<title>Document 1</title>
</head>
<body>
<p>...</p>
</body>
</xhtml>
<xhtml>
<head>
<title>Document 2</title>
</head>
<body>
<p>...</p>
</body>
</xhtml>
</env:Body>
</env:Envelope>
</xml>

<p>would be divided into three sections, one with the
<code>http://schemas.xmlsoap.org/soap/envelope/</code> namespace</p>

<xml>
<env:Envelope xmlns:env="http://schemas.xmlsoap.org/soap/envelope/">
<env:Body>
</env:Body>
</env:Envelope>
</xml>

<p>and two with the <code>http://www.w3.org/1999/xhtml</code>
namespace:</p>

<xml>
<xhtml xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Document 1</title>
</head>
<body>
<p>...</p>
</body>
</xhtml>
</xml>

<xml>
<xhtml xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Document 2</title>
</head>
<body>
<p>...</p>
</body>
</xhtml>
</xml>

<p>Note that two elements only belong to the same section if they have
a common ancestor and if all elements on the path to that common
ancestor have the same namespace.  Thus, if one of the XHTML documents
happened to contain an element from the
<code>http://schemas.xmlsoap.org/soap/envelope/</code>, it would not
be part of the same section as the root element.</p>

<p>This validation process can be refined in several ways, which
are described in the following sections.</p>

<h2>Concurrent validation</h2>

<p>Multiple <code>validate</code> elements can be specified for a
single namespace.  The effect is to validate against all of the
specified schemas.</p>

<p>For example, we might have a Schematron schema for XHTML, which
makes various checks that cannot be expressed in a grammar.  We want
to validate against both the Schematron schema and the RELAX NG
schema. The NRL schema would be like this:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl">
<namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
  <validate schema="soap-envelope.xsd"/>
</namespace>
<namespace ns="http://www.w3.org/1999/xhtml">
  <validate schema="xhtml.rng"/>
  <validate schema="xhtml.sch"/>
</namespace>
</rules>
</xml>

<h2>Built-in schemas</h2>

<p>Instead of a <code>validate</code> element, you can use an
<code>allow</code> element or a <code>reject</code> element.  These
are equivalent respectively to validating with a schema that allows
anything or with a schema that allows nothing.</p>

<p>For example, the following would allow SVG without attempting to
validate it:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl">
<namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
  <validate schema="soap-envelope.xsd"/>
</namespace>
<namespace ns="http://www.w3.org/1999/xhtml">
  <validate schema="xhtml.rng"/>
</namespace>
<namespace ns="http://www.w3.org/2000/svg">
  <allow/>
</namespace>
</rules>
</xml>

<p>Note that, just as with <code>validate</code>, <code>allow</code>
and <code>reject</code> apply to a section not to a whole subtree.
Thus, in the above example, if the SVG contained an embedded XHTML
section, then that XHTML section would be validated against
<code>xhtml.rng</code>.</p>

<h2>Namespace wildcards</h2>

<p>You can use an <code>anyNamespace</code> element instead of a
<code>namespace</code> element. This specifies a rule to be used for
an element for which there is no applicable <code>namespace</code>
rule.</p>

<p>Namespace wildcards are particularly useful in conjunction
with <code>allow</code> and <code>reject</code>. The following
will validate <i>strictly</i>, rejecting any namespace for
which no subschema is specified:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl">
<namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
  <validate schema="soap-envelope.xsd"/>
</namespace>
<namespace ns="http://www.w3.org/1999/xhtml">
  <validate schema="xhtml.rng"/>
</namespace>
<anyNamespace>
  <reject/>
</anyNamespace>
</rules>
</xml>

<p>In contrast, the following will validate <i>laxly</i>, allowing any
namespace for which no subschema is specified:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl">
<namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
  <validate schema="soap-envelope.xsd"/>
</namespace>
<namespace ns="http://www.w3.org/1999/xhtml">
  <validate schema="xhtml.rng"/>
</namespace>
<anyNamespace>
  <allow/>
</anyNamespace>
</rules>
</xml>

<p>The default is to validate strictly.  Thus, if there is no
<code>anyNamespace</code> rule, then the following rule will be
implied:</p>

<xml>
<anyNamespace>
  <reject/>
</anyNamespace>
</xml>

<h2>Modes</h2>

<p>You can apply different rules in different contexts by using
<i>modes</i>.  For example, you might want to restrict the
namespaces allowed for the root element.</p>

<p>The <code>rules</code> element for an NRL schema that uses multiple
modes does not contain <code>namespace</code> and
<code>anyNamespace</code> elements directly.  Rather, it contains
<code>mode</code> elements that in turn contain <code>namespace</code>
and <code>anyNamespace</code> elements. The <code>validate</code>
elements can specify a <code>useMode</code> attribute to change the
mode in which their child sections are processed.  The
<code>rules</code> element must have a <code>startMode</code>
attribute specifying which mode to use for the root element.</p>

<p>For example, suppose we want to require that root element come from
<code>http://schemas.xmlsoap.org/soap/envelope/</code> namespace.</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl" startMode="soap">
<mode name="soap">
  <namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
    <validate schema="soap-envelope.xsd" useMode="body"/>
  </namespace>
</mode>
<mode name="body">
  <namespace ns="http://www.w3.org/1999/xhtml">
    <validate schema="xhtml.rng"/>
  </namespace>
</mode>
</rules>
</xml>

<p>If a <code>validate</code> element does not specify a
<code>useMode</code> attribute, then the mode remains unchanged. Thus,
in the above example, child sections with the XHTML will be processed
in mode <code>body</code>, which does not allow the SOAP namespace; so
if the XHTML were to contain a SOAP <code>env:Envelope</code> element,
it would be rejected.</p>

<p>The <code>reject</code> and <code>allow</code> elements can have a
<code>useMode</code> attribute as well.</p>

<h2>Related namespaces</h2>

<p>A single subschema may not just handle a single namespace; it may
be handle two or more related namespaces.  To deal with this
possibility, NRL allows the rule for a namespace to specify that
elements from that namespace should be attached to a parent section
and be validated together with that parent section.</p>

<p>Suppose we have RELAX NG schemas for XHTML and for SVG.  We could
use these directly as subschemas in NRL.  But we might prefer instead
to use RELAX NG mechanisms to combine these into a single RELAX NG
schema. This would allow us conveniently to allow SVG elements only to
occur in places where XHTML block and inline elements are allowed and
to disallow them in places that make no sense (for example, as
children of a <code>ul</code> element).  If we have such a combined
schema, we could use it as follows:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl" startMode="soap">
<mode name="soap">
  <namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
    <validate schema="soap-envelope.xsd" useMode="xhtml"/>
  </namespace>
</mode>
<mode name="xhtml">
  <namespace ns="http://www.w3.org/1999/xhtml">
    <validate schema="xhtml+svg.rng" useMode="svg"/>
  </namespace>
</mode>
<mode name="svg">
  <namespace ns="http://www.w3.org/2000/svg">
    <attach/>
  </namespace>
</mode>
</rules>
</xml>

<p>This will cause SVG sections occurring within XHTML to be attached
to the parent XHTML section and be validated as part of it.</p>

<p>XXX introduce RDF example</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl" startMode="root">
  <mode name="root">
    <namespace ns="http://www.w3.org/1999/xhtml">
      <validate schema="xhtml.rng" useMode="body"/>
    </namespace>
  </mode>
  <mode name="body">
    <namespace ns="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <validate schema="rdfxml.rng" useMode="rdf"/>
    </namespace>
  </mode>
  <mode name="rdf">
    <anyNamespace>
      <attach/>
    </anyNamespace>
  </mode>
</rules>
</xml>

<p>XXX NRL as subschema for NRL</p>

<h2>Built-in modes</h2>

<p>There is a built-in mode named <code>#attach</code>, which contains
just the rule:</p>

<xml>
<anyNamespace>
  <attach/>
</anyNamespace>
</xml>

<p>Thus, the last example in the previous section can be simplified to:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl" startMode="root">
  <mode name="root">
    <namespace ns="http://www.w3.org/1999/xhtml">
      <validate schema="xhtml.rng" useMode="body"/>
    </namespace>
  </mode>
  <mode name="body">
    <namespace ns="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <validate schema="rdfxml.rng" useMode="#attach"/>
    </namespace>
  </mode>
</rules>
</xml>

<p>Similarly, there is a built-in mode named <code>#reject</code>,
which contains just the rule:</p>

<xml>
<anyNamespace>
  <reject/>
</anyNamespace>
</xml>

<p>and a built-in mode named <code>#allow</code>, which contains just
the rule:</p>

<xml>
<anyNamespace>
  <allow/>
</anyNamespace>
</xml>


<h2>Mode inheritance</h2>

<p>One mode can <i>extend</i> another mode. Suppose in our SOAP+XHTML
example, we want to allow both SOAP element and XHTML elements to
contain RDF.  By putting the rule for RDF in its own mode and
extending that mode, we can avoid having to specify the rule for RDF
twice:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl" startMode="soap">
<mode name="common">
  <namespace ns="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
    <validate schema="rdfxml.rng" useMode="#attach"/>
  </namespace>
</mode>
<mode name="soap" extends="common">
  <namespace ns="http://schemas.xmlsoap.org/soap/envelope/">
    <validate schema="soap-envelope.xsd" useMode="body"/>
  </namespace>
</mode>
<mode name="body" extends="common">
  <namespace ns="http://www.w3.org/1999/xhtml">
    <validate schema="xhtml.rng"/>
  </namespace>
</mode>
</rules>
</xml>

<p>It is possible to extend a built-in mode. Thus, a mode that
validates laxly can be specified simply just by extending
<code>#allow</code>.  This works because of how wildcards and
inheritance interact.  Suppose mode <var>x</var> extends mode
<var>y</var>; then when using mode <var>x</var>, the following order
will be used to search for a matching rule:</p>

<ol>
<li>a non-wildcard rule in <var>x</var></li>
<li>a non-wildcard rule in <var>y</var></li>
<li>a wildcard rule in <var>x</var></li>
<li>a wildcard rule in <var>y</var></li>
</ol>

<p>Thus, another way to specify that there is a default rule of</p>

<xml>
<anyNamespace>
  <reject/>
</anyNamespace>
</xml>

<p>is to specify that the default value of the <code>extends</code>
attribute is <code>#reject</code>.</p>

<h2>Transparent namespaces</h2>

<p>XXX</p>

<h2>Element-name context</h2>

<p>XXX</p>


<h2>Attributes</h2>

<p>Up to now, we have considered attributes to be inseparably attached
to their parent elements.  Although this is the default behaviour is
to attach attributes to their parent elements, attributes are in fact
considered to be separate sections and can be processed
separately. Attributes with the same namespace URI and same parent
element are grouped in a single section.</p>

<p>A <code>namespace</code> or <code>anyNamespace</code> element can
have a <code>match</code> attribute, whose value must be a list of one
or two of the tokens <code>attributes</code> and
<code>elements</code>. If the value includes the token
<code>attributes</code>, the rule matches attribute sections.</p>

<p>The default behaviours of attaching attributes to their parent
elements occurs because the default value of the <code>match</code>
attribute is <code>elements</code> and because all of the built-in
modes include a rule:</p>

<xml>
<anyNamespace match="attributes">
  <attach/>
</anyNamespace>
</xml>

<p>Most, if not all, XML schema languages do not have any notion of
validating a set of attributes; they know only how to validate an XML
element. Therefore, before validating an attribute section, NRL
transforms it into an XML element by creating a dummy element to hold
the attributes. NRL also performs a corresponding transformation on
the schema. This is schema-language dependent.  For example, in the
case of RELAX NG, a schema <code><var>s</var></code> is transformed to
<code>&lt;element>&lt;anyName/>&#160;<var>s</var>&#160;&lt;/element></code>.</p>

<p>For example, suppose <code>xmlatts.rng</code> contains a schema for
the attributes in the <code>xml</code> namespace written in RELAX
NG:</p>

<xml>
<group xmlns="http://relaxng.org/ns/structure/1.0"
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <optional>
    <attribute name="xml:lang">
      <choice>
        <data type="language"/>
        <value></value>
      </choice>
    </attribute>
  </optional>
  <optional>
    <attribute name="xml:base">
      <data type="anyURI"/>
    </attribute>
  </optional>
  <optional>
    <attribute name="xml:space">
      <choice>
	<value>preserve</value>
	<value>default</value>
      </choice>
    </attribute>
  </optional>
</group>
</xml>

<p>An NRL schema could use this as follows:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl">
<namespace ns="http://www.w3.org/1999/xhtml">
  <validate schema="xhtml.rng"/>
</namespace>
<namespace ns="http://www.w3.org/XML/1998/namespace" match="attributes">
  <validate schema="xmlatts.rng"/>
</namespace>
</rules>
</xml>

<h2>Related work</h2>

<p>The fundamental idea of dividing into sections, each of which
contains elements from a single namespace, and then validating each
section separately against the schema for its namespace originated in
Murata Makoto's RELAX Namespace, which formed the basis for the
recently published DSDL Part 4 CD.</p>

<p>RELAX Namespace was designed to work well with RELAX Core. RELAX
Core cannot deal with documents that use multiple namespaces, nor does
it provide any namespace-based wildcards.  These limitations of RELAX
Core are reflected in the design of RELAX Namespace.  NRL is designed
to be able to take advantage of more recent schema languages, such as
RELAX NG, that are not limited in this way.</p>

<p>In reaction to MNS, Rick Jellife produced the Namespace
Switchboard, which inspired much of the evolution of NRL from MNS.</p>

<h2>Acknowledgments</h2>

<p>Thanks to Murata Makoto and Rick Jelliffe for helpful comments.</p>

<div class="back">

<h2>References</h2>

<p>Committee Draft of Document Schema Definition Languages (DSDL) --
Part 4: Selection of Validation Candidates, <a
href="http://www.y12.doe.gov/sgml/sc34/document/0363.htm"
>http://www.y12.doe.gov/sgml/sc34/document/0363.htm</a></p>

<p>Jing validator, <a
href="http://www.thaiopensource.com/relang/jing.html"
>http://www.thaiopensource.com/relang/jing.html</a></p>

<h2>NRL schema</h2>

<p>NRL elements can be extended with arbitrary attributes provided the
attributes are namespace qualified and their namespace is not the NRL
namespace; they can also be extended with arbitrary child elements
with any namespace (including the absent namespace) other than the NRL
namespace. We could provide a RELAX NG schema that fully described
NRL, but the extensibility would make the schema harder to understand.
So instead we provide a RELAX NG schema (in compact syntax) that does
not allow extensibility, and provide an NRL schema to make it
extensible.</p>

<p>Thus, NRL is described by the following NRL schema:</p>

<xml>
<rules xmlns="http://www.thaiopensource.com/validate/nrl" startMode="root">
<mode name="root">
  <namespace ns="http://www.thaiopensource.com/validate/nrl">
    <validate schema="nrl.rnc" schemaType="application/x-rnc" useMode="extend"/>
  </namespace>
</mode>
<mode name="extend">
  <namespace ns="http://www.thaiopensource.com/validate/nrl" match="attributes">
    <reject/>
  </namespace>
  <namespace ns="" match="attributes">
    <attach/>
  </namespace>
  <anyNamespace match="elements attributes">
    <allow useMode="#attach"/>
  </anyNamespace>
</mode>
</rules>
</xml>

<p>where <code>nrl.rnc</code> is as follows:</p>

<pre>
default namespace = "http://www.thaiopensource.com/validate/nrl"

start =
  element rules {
    schemaType?,
    (rule* | (attribute startMode { modeName }, mode+))
  }

mode =
  element mode {
    attribute name { userModeName },
    attribute extends { modeName }?,
    rule*
  }

rule =
  element namespace {
    attribute ns { xsd:anyURI },
    ruleModel
  }
  | element anyNamespace { ruleModel }

ruleModel = attribute match { elementsOrAttributes }?, actions

elementsOrAttributes =
  list {
    ("elements", "attributes") 
     | ("attributes", "elements") 
     | "elements"
     | "attributes"
  }

actions =
  noResultAction*, (noResultAction|resultAction), noResultAction*

noResultAction =
  element validate {
    attribute schema { xsd:anyURI },
    schemaType?,
    option*,
    modeUsage
  }
  | element allow|reject { modeUsage }

resultAction =
  element attach|ignore { modeUsage }

option =
  element option {
    attribute name { xsd:anyURI },
    attribute arg { text }?,
    attribute mustSupport { xsd:boolean }?
  }

modeUsage =
  attribute useMode { modeName }?,
  element context {
    attribute path { path },
    attribute useMode { modeName }?
  }*

modeName = userModeName | builtinModeName

userModeName = xsd:NCName
builtinModeName = "#attach" | "#allow" | "#reject" | "#ignore"

schemaType = attribute schemaType { mediaType }
mediaType = xsd:string  # should do better than this
path =
  xsd:string {
    pattern = "\s*(/\s*)?\i\c*(\s*/\s*\i\c*)*\s*"
              ~ "(|\s*(/\s*)?\i\c*(\s*/\s*\i\c*)*\s*)*"
  }
</pre>

</div>

</body>
</html>
