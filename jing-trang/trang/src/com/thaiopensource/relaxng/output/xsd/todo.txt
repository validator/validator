We can get (x | (y | z)) if (y|z) was a name class.  Simplify into x|y|z.

Check for duplicate attributes.

Check for violations of RELAX NG interleave restriction.

Approximation warnings:
- interleave
- mixed text
- list containing a group of two non-empty tokens
- element wildcard with content that does not allow everything
- wildcards with two or more negative namespaces
- wildcards with negative single names
- choice between attributes
- choice between elements and data

Provide annotation to control which target namespace is assigned to a file.

Take advantage of minOccurs > 1 and 1 < maxOccurs < infinity.

If expansion of a group causes the group to become unreferenced, then remove the group.

If define referenced only in something that is unreachable because of notAllowed, remove the define.

Use complexTypes for groups and simpleTypes with associated attributes, even if not all references can
make use of them.

Use the last component of the namespace URI in selecting prefix and generated schema file when no prefix is used in the
RELAX NG.

Try using default namespace declaration to refer to things in targetNamespace.

Make choice of targetNamespace not depend on order of hash table iteration.

Handle nested grammars (use different namespace for different grammars).

Turn overrides into <redefine>.

Preserve definitions that are equivalent to empty or notAllowed.

Handle externalRef (remember problem with parentRef in externalRef)

Interleave
- Avoid introducing ambiguities when approximating <interleave>, eg x & (y, y).
- Optimize nested choices in expanding <interleave>.
- Optimize eg x* & (a, b, c) into x*, (a, x*), (b, x*), (c, x*)

For a <value type="NOTATION"/>, map to NOTATION and generate an
appropriate xs:notation declaration based on annotations.

Deal with xsi attributes.

Make use of element substitution groups; may affect which elements are
global.  A group that consists of a choice of global elements is
eligible to made a substitution group; the choice may also contain
references to groups that are themselves eligible to be substitution
groups. The choice should not have any annotations. If the name of the
group is the same as the name of one of the elements in the choice,
then the group disappears and that element becomes the head; in this
case, the use of a substitution group should probably be prevented if
the define has an annotation.  If the name of the group is not the
same as one of the elements of the choice, then we generate an
abstract element with the same name of the group. What if the name of
the group clashes with an existing non-abstract global element?  We
should probably try to avoid this situation when choosing which
element particles are to become global elements.  If we cannot, we
could either forgo the use of a substitution group, or modify the name
by adding a prefix or suffix.  The possibility of using a substitution
group should be able to influence whether we choose to use a global
element for a particular element particle.

A define whose pattern is equivalent to notAllowed should be preserved
in the intermediate form, since it may correspond to the abstract head
of a subsitution group (probably need an annotation to control this).

Better support for combine="choice".  If element substitution groups
are supported, then combine="choice" can be supported much better.
Intermediate form needs support for combine="choice".  If a
combine="choice" turns out to be substition group, then there's no
problem.  Otherwise we can distinguish three cases:

- same file: choose one to be the main definition; for the others two
strategies: (a) move into the main (b) modify the name and add
reference to it to the main definition

- same file, different target namespace: preserve separate
definitions; either generate new definition in different namespace to
combine them or choose on of the target namespaces to be the main one

- same file, same target namespace: files are related by include; try
to use redefine; can combine two definitions from include parent and
include descendant, not two definitions from two include children; in
this case, rename defines in childen and add define to parent.

Deal with comments

Deal with annotations (provide special support for xs:key/xs:keyRef/xs:unique).

Better support for xsd:documentation:
- copy xsd:documentation annotations
- copy xml:lang attribute from a:documentation elements
- allow multiple a:documentation elements

Be more careful about preserving annotations.

Deal with element type consistent restriction

Deal with ambiguous content model restriction

Avoid redundant imports and redundant namespace declarations.

With combine attributes, maybe insert <ref> to preserve file structure.

Deal with repeated inclusions of same file, by expanding.

Add an annotation on elements to convey <start> info.
