datatypes w = "http://whattf.org/datatype-draft"

# #####################################################################
##  RELAX NG Schema for HTML 5: Web Forms 1.0 markup                  #
# #####################################################################

## Groups of shared attributes

# Shared by all form controls
	common-form.attrs =
		(	common-form.attrs.name?
		&	common-form.attrs.disabled?
		&	common-form.attrs.form?
		)

# Shared by all single or multiple line text edit controls
	shared-form.attrs.text-edit =
		(	common-form.attrs
		&	shared-form.attrs.minlength?
		&	shared-form.attrs.maxlength?
		&	shared-form.attrs.required?
		&	shared-form.attrs.readonly?
		)

# Shared by all single-line text edit controls
	shared-form.attrs.single-line-text-edit =
		(	shared-form.attrs.text-edit
		&	input.attrs.autocomplete?
		&	shared-form.attrs.placeholder?
		&	aria.prop.placeholder?
		&	shared-form.attrs.pattern?
		&	shared-form.attrs.size?
		)

# Shared by all date & time controls
	shared-form.attrs.date-time =
		(	common-form.attrs?
		&	input.attrs.autocomplete?
		&	input.attrs.list?
		&	shared-form.attrs.required?
		&	aria.prop.required?
		&	shared-form.attrs.readonly?
		)

# Shared by all buttons able to submit the form
	shared-form.attrs.submit = 
		(	common-form.attrs?
		&	shared-form.attrs.formaction?
		&	shared-form.attrs.formenctype?
		&	shared-form.attrs.formmethod?
		&	shared-form.attrs.formtarget?
		&	shared-form.attrs.formnovalidate?
		)

## Shared attributes by all form controls
		
	common-form.attrs.name = 
		attribute name {
			form.data.nonemptystring
		}

	common-form.attrs.disabled = 
		attribute disabled {
			w:string "disabled" | w:string ""
		}

	common-form.attrs.form |= 
		attribute form {
			common.data.idref
		}
		
## Shared attributes by most of control fields

	input.attrs.autocomplete.any =
		attribute autocomplete {
			(	w:string "on" | w:string "off"
			|	common.data.autocomplete.any
			)
		}

	input.attrs.autocomplete =
		attribute autocomplete {
			string
		}

	input.attrs.list = 
		attribute list {
			common.data.idref
		}

	shared-form.attrs.required = 
		attribute required {
			w:string "required" | w:string ""
		}

	shared-form.attrs.readonly = 
		attribute readonly {
			w:string "readonly" | w:string ""
		}

## Shared attributes by all single-line text control fields

	shared-form.attrs.minlength =
		attribute minlength {
			common.data.integer.non-negative
		}

	shared-form.attrs.maxlength = 
		attribute maxlength {
			common.data.integer.non-negative
		}

	shared-form.attrs.pattern = 
		attribute pattern {
			form.data.pattern
		}

	shared-form.attrs.placeholder = 
		attribute placeholder {
			form.data.stringwithoutlinebreaks
		}

	shared-form.attrs.size = 
		attribute size {
			common.data.integer.positive
		}
	
	# REVISIT tabindex goes in common.attrs

## Shared attributes by buttons able to submit the form

	shared-form.attrs.formaction =
		attribute formaction {
			common.data.uri.non-empty
		}

	shared-form.attrs.formenctype =
		attribute formenctype {
			shared-form.attrs.formenctype.data
		}
		shared-form.attrs.formenctype.data = 
			(	w:string "application/x-www-form-urlencoded" 
			|	w:string "multipart/form-data"
			|	w:string "text/plain"
			)

	shared-form.attrs.formmethod =
		attribute formmethod {
			shared-form.attrs.formmethod.data
		}
		shared-form.attrs.formmethod.data = 
			( w:string "get"
			| w:string "post"
			| w:string "dialog"
			)

	shared-form.attrs.formtarget = 
		attribute formtarget {
			common.data.browsing-context-or-keyword
		}

	shared-form.attrs.formnovalidate = 
		attribute formnovalidate {
			w:string "formnovalidate" | w:string ""
		}

## Other shared attributes
	
	input.attrs.checked = 
		attribute checked {
			w:string "checked" | w:string ""
		}

	shared-form.attrs.dirname = 
		attribute dirname {
			form.data.nonemptystring
		}

	input.attrs.multiple = 
		attribute multiple {
			w:string "multiple" | w:string ""
		}

	input.attrs.step.float = 
		attribute step {
			w:string "any" | common.data.float.positive
		}

	input.attrs.step.integer = 
		attribute step {
			w:string "any" | common.data.integer.positive 
		}

## Text Field: <input type='text'>

	input.text.elem = 
		element input { input.text.attrs }
	input.text.attrs = 
		(	common.attrs
		&	input.text.attrs.type?
		&	input.text.attrs.value? 
		&	shared-form.attrs.single-line-text-edit
		&	shared-form.attrs.dirname? 
		&	input.attrs.list?
		&	(	common.attrs.aria.implicit.textbox
			|	common.attrs.aria.role.textbox
			|	common.attrs.aria.role.combobox
			|	common.attrs.aria.role.searchbox
			|	common.attrs.aria.role.spinbutton
			)?
		)
		input.text.attrs.type = 
			attribute type {
				w:string "text"
			}
		input.text.attrs.value =
			attribute value {
				form.data.stringwithoutlinebreaks
			}
		
	input.elem = input.text.elem

## Password Field: <input type='password'>

	input.password.elem = 
		element input { input.password.attrs }
	input.password.attrs = 
		(	common.attrs
		&	input.password.attrs.type
		&	input.password.attrs.value? 
		&	shared-form.attrs.single-line-text-edit
		&	aria.prop.required?
		)
		input.password.attrs.type = 
			attribute type {
				w:string "password"
			}
		input.password.attrs.value =
			attribute value {
				form.data.stringwithoutlinebreaks
			}
		
	input.elem |= input.password.elem
		
## Checkbox: <input type='checkbox'>

	input.checkbox.elem = 
		element input { input.checkbox.attrs }
	input.checkbox.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.attrs.checked?
		&	shared-form.attrs.required?
		&	aria.prop.required?
		&	input.checkbox.attrs.type
		&	input.checkbox.attrs.value? 
		&	(	common.attrs.aria.implicit.checkbox
			|	common.attrs.aria.role.checkbox
			|	common.attrs.aria.role.button
			|	common.attrs.aria.role.menuitemcheckbox-checked-not-required
			|	common.attrs.aria.role.option
			|	common.attrs.aria.role.switch-checked-not-required
			)?
		)
		input.checkbox.attrs.type = 
			attribute type {
				w:string "checkbox"
			}
		input.checkbox.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.checkbox.elem
	
## Radiobutton: <input type='radio'>

	input.radio.elem = 
		element input { input.radio.attrs }
	input.radio.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.attrs.checked?
		&	shared-form.attrs.required?
		&	aria.prop.required?
		&	input.radio.attrs.type
		&	input.radio.attrs.value? 
		&	(	common.attrs.aria.implicit.radio
			|	common.attrs.aria.role.radio
			|	common.attrs.aria.role.menuitemradio-checked-not-required
			)?
		)
		input.radio.attrs.type = 
			attribute type {
				w:string "radio"
			}
		input.radio.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.radio.elem
	
## Scripting Hook Button: <input type='button'>

	input.button.elem = 
		element input { input.button.attrs }
	input.button.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.button.attrs.type
		&	input.button.attrs.value? 
		&	(	common.attrs.aria.implicit.button
			|	common.attrs.aria.role.button
			|	common.attrs.aria.role.checkbox
			|	common.attrs.aria.role.combobox
			|	common.attrs.aria.role.link
			|	common.attrs.aria.role.menuitem
			|	common.attrs.aria.role.menuitemcheckbox
			|	common.attrs.aria.role.menuitemradio
			|	common.attrs.aria.role.option
			|	common.attrs.aria.role.radio
			|	common.attrs.aria.role.switch
			|	common.attrs.aria.role.tab
			)?
		)
		input.button.attrs.type = 
			attribute type {
				w:string "button"
			}
		input.button.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.button.elem
	#REVISIT should this be enabled by a scripting module only?
	
## Submit Button: <input type='submit'>

	input.submit.elem = 
		element input { input.submit.attrs }
	input.submit.attrs = 
		(	common.attrs
		&	shared-form.attrs.submit
		&	input.submit.attrs.type
		&	input.submit.attrs.value? 
		&	(	common.attrs.aria.implicit.button
			|	common.attrs.aria.role.button
			)?
		)
		input.submit.attrs.type = 
			attribute type {
				w:string "submit"
			}
		input.submit.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.submit.elem
		
## Reset Button: <input type='reset'>

	input.reset.elem = 
		element input { input.reset.attrs }
	input.reset.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.reset.attrs.type
		&	input.reset.attrs.value? 
		&	(	common.attrs.aria.implicit.button
			|	common.attrs.aria.role.button
			)?
		)
		input.reset.attrs.type = 
			attribute type {
				w:string "reset"
			}
		input.reset.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.reset.elem
	# REVISIT does reset make sense outside a form?
		
## File Upload: <input type='file'>

	input.file.elem = 
		element input { input.file.attrs }
	input.file.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.attrs.multiple?
		&	shared-form.attrs.required?
		&	aria.prop.required?
		&	input.file.attrs.type
		&	input.file.attrs.accept?
		&	input.input.attrs.capture?
		)
		input.file.attrs.type = 
			attribute type {
				w:string "file"
			}
		input.file.attrs.accept = 
			attribute accept {
				form.data.mimetypelist
			}
		input.input.attrs.capture =
			attribute capture {
				w:string "user" | w:string "environment"
			}

	input.elem |= input.file.elem
	
## Hidden String: <input type='hidden'>

	input.hidden.elem = 
		element input { input.hidden.attrs }
	input.hidden.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.attrs.autocomplete?
		&	input.hidden.attrs.type
		&	input.hidden.attrs.value? 
		)
		input.hidden.attrs.type = 
			attribute type {
				w:string "hidden"
			}
		input.hidden.attrs.value =
			attribute value {
				string
			}
		
	input.elem |= input.hidden.elem
		
## Image Submit Button: <input type='image'>

	input.image.elem = 
		element input { input.image.attrs }
	input.image.attrs = 
		(	common.attrs
		&	shared-form.attrs.submit
		&	input.image.attrs.type
		&	input.image.attrs.alt 
		&	input.image.attrs.src? 
		&	input.image.attrs.height?
		&	input.image.attrs.width?
		&	(	common.attrs.aria.implicit.button
			|	common.attrs.aria.role.button
			|	common.attrs.aria.role.link
			|	common.attrs.aria.role.menuitem
			|	common.attrs.aria.role.menuitemcheckbox
			|	common.attrs.aria.role.menuitemradio
			|	common.attrs.aria.role.radio
			|	common.attrs.aria.role.switch
			)?
		)	
		input.image.attrs.type = 
			attribute type {
				w:string "image"
			}
		input.image.attrs.alt = 
			attribute alt {
				form.data.nonemptystring
			}
		input.image.attrs.src = 
			attribute src {
				common.data.uri.non-empty
			}
		input.image.attrs.height =
			attribute height {
				common.data.integer.non-negative
			}
		input.image.attrs.width =
			attribute width {
				common.data.integer.non-negative
			}
	
	input.elem |= input.image.elem
	
	common.elem.phrasing |= input.elem

## Text Area: <textarea>

	textarea.elem =
		element textarea { textarea.inner & textarea.attrs }
	textarea.attrs =
		(	common.attrs
		&	shared-form.attrs.text-edit
		&	shared-form.attrs.dirname? 
		&	textarea.attrs.rows-and-cols-wf1
		&	(	common.attrs.aria.implicit.textbox
			|	common.attrs.aria.role.textbox
			)?
		#FIXME onfocus, onblur, onselect,onchange
		)
		# This is ugly. 
		textarea.attrs.rows-and-cols-wf1 = 
			textarea.attrs.rows-and-cols-wf1.inner	
		textarea.attrs.rows-and-cols-wf1.inner =
			(	textarea.attrs.cols
			&	textarea.attrs.rows
			)
		textarea.attrs.cols = 
			attribute cols {
				common.data.integer.positive
			}
		textarea.attrs.rows = 
			attribute rows {
				common.data.integer.positive
			}
	textarea.inner =
		( text )

	common.elem.phrasing |= textarea.elem

# Due to limitations with interleave, handling single/multiple selection
# enforcement in RELAX NG seems to be possible but really awkward.
# Tried it. Leaving it to Schematron.

## Select menu option: <option selected>

	option.elem =
		element option { option.inner & option.attrs }
	option.attrs =
		(	common.attrs
		&	common-form.attrs.disabled?
		&	option.attrs.selected?
		&	option.attrs.label?
		&	option.attrs.value?
		&	(	common.attrs.aria.implicit.option
			|	common.attrs.aria.role.option
			)?
		)
		option.attrs.selected =
			attribute selected {
				w:string "selected" | w:string ""
			}
		option.attrs.label =
			attribute label {
				form.data.nonemptystring
			}		
		option.attrs.value =
			attribute value {
				string
			}		
	option.inner =
		( text )

## Option Group: <optgroup>

	optgroup.elem =
		element optgroup { optgroup.inner & optgroup.attrs }
	optgroup.attrs = 
		(	common.attrs
		&	optgroup.attrs.label
		&	common-form.attrs.disabled?
		&	(	common.attrs.aria.implicit.group
			|	common.attrs.aria.role.group
			)?
		)
		optgroup.attrs.label =
			attribute label {
				string
			}
	optgroup.inner =
		(	option.elem*
		&	common.elem.script-supporting*
		)

## Selection Menu: <select>

	select.elem =
		element select { select.inner & select.attrs }
	select.attrs =
		(	common.attrs
		&	common-form.attrs
		&	select.attrs.size?
		&	select.attrs.multiple?
		# FIXME onfocus, onblur, onchange
		&	(	common.attrs.aria.role.listbox # aria-multiselectable depends on "multiple" value; check in assertions
			|	common.attrs.aria.role.combobox
			|	common.attrs.aria.role.menu
			|	common.attrs.aria.implicit.combobox
			|	common.attrs.aria.implicit.listbox
			)?
		)
		select.attrs.size =
			attribute size {
				common.data.integer.positive
			}
		select.attrs.multiple =
			attribute multiple {
				w:string "multiple" | w:string ""
			}
	select.inner =
		(	optgroup.elem*
		&	option.elem*
		&	common.elem.script-supporting*
		)

	common.elem.phrasing |= select.elem
	
## Shared Definitions for Complex Button
	
	button.attrs.value =
		attribute value {
			string
		}
	button.inner = 
		( common.inner.phrasing )
	
## Complex Submit Button: <button type='submit'>

	button.submit.elem =
		element button { button.inner & button.submit.attrs }	
	button.submit.attrs =
		(	common.attrs
		&	shared-form.attrs.submit
		&	button.submit.attrs.type?
		&	button.attrs.value?
		&	(	common.attrs.aria.implicit.button
			|	common.attrs.aria.role.button
			|	common.attrs.aria.role.checkbox
			|	common.attrs.aria.role.combobox
			|	common.attrs.aria.role.link
			|	common.attrs.aria.role.menuitem
			|	common.attrs.aria.role.menuitemcheckbox
			|	common.attrs.aria.role.menuitemradio
			|	common.attrs.aria.role.option
			|	common.attrs.aria.role.radio
			|	common.attrs.aria.role.tab
			)?
		)
		button.submit.attrs.type =
			attribute type {
				w:string "submit"
			}

	button.elem = button.submit.elem
	
## Complex Reset Button: <button type='reset'>

	button.reset.elem =
		element button { button.inner & button.reset.attrs }	
	button.reset.attrs =
		(	common.attrs
		&	common-form.attrs
		&	button.reset.attrs.type
		&	button.attrs.value? #REVISIT I guess this still affects the DOM
		&	(	common.attrs.aria.implicit.button
			|	common.attrs.aria.role.button
			|	common.attrs.aria.role.checkbox
			|	common.attrs.aria.role.link
			|	common.attrs.aria.role.menuitem
			|	common.attrs.aria.role.menuitemcheckbox
			|	common.attrs.aria.role.menuitemradio
			|	common.attrs.aria.role.option
			|	common.attrs.aria.role.radio
			|	common.attrs.aria.role.switch
			)?
		)
		button.reset.attrs.type =
			attribute type {
				w:string "reset"
			}

	button.elem |= button.reset.elem
	
## Complex Push Button: <button type='button'>

	button.button.elem =
		element button { button.inner & button.button.attrs }	
	button.button.attrs =
		(	common.attrs
		&	common-form.attrs
		&	button.button.attrs.type
		&	button.attrs.value? #REVISIT I guess this still affects the DOM
		&	(	common.attrs.aria.implicit.button
			|	common.attrs.aria.role.button
			|	common.attrs.aria.role.checkbox
			|	common.attrs.aria.role.link
			|	common.attrs.aria.role.menuitem
			|	common.attrs.aria.role.menuitemcheckbox
			|	common.attrs.aria.role.menuitemradio
			|	common.attrs.aria.role.option
			|	common.attrs.aria.role.radio
			|	common.attrs.aria.role.switch
			|	common.attrs.aria.role.tab
			)?
		)
		button.button.attrs.type =
			attribute type {
				w:string "button"
			}

	button.elem |= button.button.elem

	common.elem.phrasing |= button.elem

## Form: <form>

	form.elem =
		element form { form.inner & form.attrs }
	form.attrs =
		(	common.attrs
		&	form.attrs.action? #REVISIT Should this be required anyway?
		&	form.attrs.method?
		&	form.attrs.enctype?
		&	common-form.attrs.name?
		&	form.attrs.accept-charset?
		&	(	common.attrs.aria.implicit.form
			|	common.attrs.aria.landmark.form
			|	common.attrs.aria.landmark.search
			|	common.attrs.aria.role.presentation
			)?
		)
		form.attrs.action =
			attribute action {
				common.data.uri.non-empty
			}
		form.attrs.method =
			attribute method {
				form.attrs.method.data
			}
			form.attrs.method.data = 
				( w:string "get"
				| w:string "post"
				| w:string "dialog"
				)
		form.attrs.enctype =
			attribute enctype {
				form.attrs.enctype.data
			}
			form.attrs.enctype.data = 
				(	w:string "application/x-www-form-urlencoded" 
				|	w:string "multipart/form-data"
				)
		form.attrs.accept-charset =
			attribute accept-charset {
				string
			}	
	form.inner =
		( common.inner.flow )

	common.elem.flow |= form.elem

## Fieldset: <fieldset>

	fieldset.elem =
		element fieldset { fieldset.inner & fieldset.attrs }
	fieldset.attrs =
		(	common.attrs
		&	(	common.attrs.aria.implicit.group
			|	common.attrs.aria.role.group
			|	common.attrs.aria.role.radiogroup
			|	common.attrs.aria.role.presentation
			)?
		)
	fieldset.inner =
		legend.elem?, common.inner.flow

	common.elem.flow |= fieldset.elem
	
## Label: <label>

	label.elem =
		element label { label.inner & label.attrs }
	label.attrs =
		(	common.attrs
		&	label.attrs.for?
		)
		label.attrs.for =
			attribute for {
				common.data.idref
			}
	label.inner =
		( common.inner.phrasing ) #REVISIT making obvious guess

	common.elem.phrasing |= label.elem

